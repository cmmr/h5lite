name: rchk (Kalibera)

on:
  workflow_dispatch:
  pull_request:
  push:
    branches: [master]
    paths:
      - src/**
      - .github/workflows/rchk.yaml

jobs:
  rchk:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Create Check Script
        run: |
          mkdir -p packages
          cat <<EOF > packages/check.R
          # 0. Capture the container's starting directory (the R source root)
          r_source_root <- getwd()

          # 1. Setup a local library directory in the mounted volume
          lib_dir <- "/rchk/packages/library"
          dir.create(lib_dir, recursive = TRUE, showWarnings = FALSE)
          .libPaths(c(lib_dir, .libPaths()))

          # 2. Install remotes
          install.packages("remotes", repos = "https://cloud.r-project.org", lib = lib_dir)

          # 3. Define source directory (mapped from host)
          pkg_src <- "/rchk/source"
          
          # 4. Install dependencies
          #    We force --no-clean to preserve bitcode for static libraries like hdf5lib
          remotes::install_deps(
            pkg_src, 
            dependencies = c("Depends", "Imports", "LinkingTo"), 
            repos = "https://cloud.r-project.org",
            lib = lib_dir,
            INSTALL_opts = c("--no-clean", "--no-byte-compile")
          )

          # 5. Build the package tarball
          #    We switch to /rchk/packages to ensure we have write permissions for the tarball
          setwd("/rchk/packages")
          cmd_build <- sprintf("R CMD build --no-manual --no-build-vignettes '%s'", pkg_src)
          if (system(cmd_build) != 0) stop("Failed to build package tarball")
          
          #    Identify the generated tarball
          pkg_tar <- list.files(pattern = "\\\\.tar\\\\.gz$")[1]
          pkg_name <- gsub("_.*", "", pkg_tar)

          # 6. Install the package libs for rchk analysis
          source("/rchk/scripts/utils.r")
          install_package_libs(pkg_tar, target = "/rchk/packages/libsonly")

          # 7. Run the actual check
          #    IMPORTANT: We must switch back to the R source root for the check script to work
          setwd(r_source_root)
          
          cmd_check <- paste("/rchk/scripts/check_package.sh", pkg_name)
          if (system(cmd_check) != 0) quit(status = 1)

          # 8. Verify Results
          #    The rchk tool writes report files to:
          #    /rchk/packages/libsonly/<pkg>/libs/<pkg>.so.{maacheck,bcheck}
          
          libs_dir      <- file.path("/rchk/packages", "libsonly", pkg_name, "libs")
          maacheck_file <- file.path(libs_dir, paste0(pkg_name, ".so.maacheck"))
          bcheck_file   <- file.path(libs_dir, paste0(pkg_name, ".so.bcheck"))
          
          if (!file.exists(maacheck_file) || !file.exists(bcheck_file)) {
             stop("Check files not found. The rchk run likely failed.")
          }

          # Process bcheck errors
          # Ignore "too many states" warnings and the summary line
          b_errors <- readLines(bcheck_file)
          b_errors <- b_errors[!grepl("too many states", b_errors)]
          b_errors <- b_errors[!grepl("^Analyzed [0-9]+ functions", b_errors)]

          # Process maacheck errors (anything here is a failure)
          m_errors <- readLines(maacheck_file)
          
          # Combine and filter empty lines
          all_errors <- c(b_errors, m_errors)
          all_errors <- all_errors[nzchar(all_errors)]
          
          if (length(all_errors) > 0) {
            cat("\n\nFAILURE: rchk found errors:\n")
            cat(paste(all_errors, collapse = "\n"), "\n")
            quit(status = 1)
          } else {
            cat("\nSUCCESS: No memory protection errors found by rchk.\n")
            quit(status = 0)
          }
          EOF

      - name: Run rchk
        run: |
          docker pull kalibera/rchk:latest
          docker run --rm \
            -v "$PWD:/rchk/source" \
            -v "$PWD/packages:/rchk/packages" \
            kalibera/rchk:latest \
            R -f /rchk/packages/check.R
