% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/write.r
\name{h5_write}
\alias{h5_write}
\title{Write an R Object to HDF5}
\usage{
h5_write(data, file, name, attr = NULL, as = "auto", compress = TRUE)
}
\arguments{
\item{data}{The R object to write. Supported: \code{numeric}, \code{integer}, \code{complex},
\code{logical}, \code{character}, \code{factor}, \code{raw}, \code{matrix}, \code{data.frame}, \code{NULL},
and nested \code{list}s.}

\item{file}{The path to the HDF5 file.}

\item{name}{The name of the dataset or group to write (e.g., "/data/matrix").}

\item{attr}{The name of an attribute to write.
\itemize{
\item If \code{NULL} (default), \code{data} is written as a dataset or group at the path \code{name}.
\item If provided (string), \code{data} is written as an attribute named \code{attr} attached to the object \code{name}.
}}

\item{as}{The target HDF5 data type. Defaults to \code{"auto"}.
See the \strong{Data Type Selection} section for a full list of valid options
(including \code{"int64"}, \code{"bfloat16"}, \code{"utf8[n]"}, etc.) and how to map
specific columns.}

\item{compress}{Compression configuration.
\itemize{
\item \code{TRUE} (default): Enables compression (zlib level 5).
\item \code{FALSE} or \code{0}: Disables compression.
\item Integer \code{1-9}: Specifies the zlib compression level.
}}
}
\value{
Invisibly returns \code{file}. This function is called for its side effects.
}
\description{
Writes an R object to an HDF5 file, creating the file if it does not exist.
This function acts as a unified writer for datasets, groups (lists), and attributes.
}
\section{Data Type Selection (\code{as} Argument)}{

The \code{as} argument controls the on-disk storage type for integer, double,
logical, and character columns.

\strong{1. Available Types}
\itemize{
\item \strong{Floating Point:} \code{"float16"}, \code{"float32"}, \code{"float64"}, \code{"bfloat16"}
\item \strong{Signed Integer:} \code{"int8"}, \code{"int16"}, \code{"int32"}, \code{"int64"}
\item \strong{Unsigned Integer:} \code{"uint8"}, \code{"uint16"}, \code{"uint32"}, \code{"uint64"}
\item \strong{Variable Length Strings:} \code{"utf8"}, \code{"ascii"}
\item \strong{Fixed Length Strings:}
\itemize{
\item \code{"utf8[]"} or \code{"ascii[]"} (auto-detects the longest string in the data)
\item \code{"utf8[n]"} or \code{"ascii[n]"} (where \code{n} is the length in bytes, e.g., \code{"utf8[10]"})
}
\item \strong{Other:} \code{"auto"}, \code{"skip"} (to skip a column/attribute of any R type)
}

\emph{Strings:} Variable-length strings allow for \code{NA} values (via NULL pointers)
but cannot be compressed. Fixed-length strings allow for compression but do
not support \code{NA}.

\strong{2. Automatic Selection (\code{as = "auto"})}

\tabular{lll}{
\strong{R Type} \tab \strong{HDF5 Type} \tab \strong{Notes} \cr
\code{integer}    \tab \code{H5T_STD_I32LE}  \tab  \cr
\code{double}     \tab \code{H5T_IEEE_F64LE} \tab  \cr
\code{logical}    \tab \code{H5T_STD_U8LE}   \tab 1-bit storage efficiency. \cr
\code{character}  \tab \code{H5T_C_S1}       \tab \verb{H5T_CSET_UTF8 H5T_VARIABLE H5T_STR_NULLTERM} \cr
\code{factor}     \tab \code{H5T_ENUM}       \tab Maps levels to integers. \cr
\code{data.frame} \tab \code{H5T_COMPOUND}   \tab Native table-like structure. \cr
\code{list}       \tab \code{H5O_TYPE_GROUP} \tab Written to HDF5 recursively. \cr
\code{complex}    \tab \code{H5T_COMPLEX_IEEE_F64LE} \tab Requires HDF5 >= 2.0.0. \cr
\code{raw}        \tab \code{H5T_OPAQUE}     \tab For binary data storage. \cr
\code{NULL}       \tab \code{H5S_NULL}       \tab Null Dataspace \cr
\code{integer64}  \tab \code{H5T_STD_I64LE}  \tab From the \code{bit64} R package. \cr
\code{POSIXt}     \tab \code{H5T_C_S1}       \tab ISO 8601 string (\code{YYYY-MM-DDTHH:MM:SSZ}) \cr
}

\emph{NA Handling:} HDF5 integers do not support \code{NA}. If an R integer or logical
vector contains \code{NA}, \code{h5lite} automatically promotes it to \code{float64} to
preserve the \code{NA} value.

\strong{3. Column/Class Mapping}

You can provide a named vector to map specific columns or classes:
\itemize{
\item \strong{Specific Name:} \code{"col_name" = "type"} (e.g., \code{c(score = "float32")})
\item \strong{Specific Attribute:} \code{"@attr_name" = "type"}
\item \strong{Class-based:} \code{".integer" = "type"}, \code{".numeric" = "type"}
\item \strong{Class-based Attribute:} \code{"@.character" = "type"}, \code{"@.logical" = "type"}
\item \strong{Global Fallback:} \code{"." = "type"}
\item \strong{Global Attribute Fallback:} \code{"@." = "type"}
}

\emph{Numeric Class:} \code{".numeric"} targets both \code{integer} and \code{double} with a
lower priority than \code{".integer"} and \code{".double"}.
}

\section{Writing Scalars}{

By default, \code{h5_write} saves single-element vectors as 1-dimensional arrays.
To write a true HDF5 scalar, wrap the value in \code{I()} to treat it "as-is."
For example, \code{h5_write(I(5), file, "x")} will create a scalar dataset, while
\code{h5_write(5, file, "x")} will create a 1D array of length 1.
}

\section{Dimension Scales}{

\code{h5lite} automatically writes \code{names}, \code{row.names}, and \code{dimnames} as
HDF5 dimension scales. Named vectors will generate an \verb{<name>_names}
dataset. A data.frame with row names will generate an \verb{<name>_rownames}
dataset (column names are saved internally in the original dataset).
Matrices will generate \verb{<name>_rownames} and \verb{<name>_colnames} datasets.
Arrays will generate \verb{<name>_dimscale_1}, \verb{<name>_dimscale_2}, etc.
Special HDF5 metadata attributes link the dimension scales to the dataset.
The dimension scales can be relocated with \code{h5_move()} without breaking the
link.
}

\examples{
file <- tempfile(fileext = ".h5")

# 1. Writing Basic Datasets
h5_write(1:10, file, "data/integers")
h5_write(rnorm(10), file, "data/floats")
h5_write(letters[1:5], file, "data/chars")

# 2. Writing Attributes
# Write an object first
h5_write(1:10, file, "data/vector")
# Attach an attribute to it using the 'attr' parameter
h5_write(I("My Description"), file, "data/vector", attr = "description")
h5_write(I(100), file, "data/vector", attr = "scale_factor")

# 3. Controlling Data Types
# Store integers as 8-bit unsigned
h5_write(1:5, file, "compressed/small_ints", as = "uint8")

# 4. Writing Complex Structures (Lists/Groups)
my_list <- list(
  meta    = list(id = 1, name = "Experiment A"),
  results = matrix(runif(9), 3, 3),
  valid   = I(TRUE)
)
h5_write(my_list, file, "experiment_1", as = c(id = "uint16"))

# 5. Writing Data Frames (Compound Datasets)
df <- data.frame(
  id    = 1:5,
  score = c(10.5, 9.2, 8.4, 7.1, 6.0),
  grade = factor(c("A", "A", "B", "C", "D"))
)
h5_write(df, file, "records/scores", as = c(grade = "ascii[1]"))

# 6. Fixed-Length Strings
h5_write(c("A", "B"), file, "fixed_str", as = "ascii[10]")

# 7. Review the file structure
h5_str(file)

# 8. Clean up
unlink(file)
}
\seealso{
\code{\link[=h5_read]{h5_read()}}
}
