% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/write.r
\name{h5_write}
\alias{h5_write}
\title{Write a Dataset to HDF5}
\usage{
h5_write(
  file,
  name,
  data,
  dtype = "auto",
  dims = "auto",
  compress = TRUE,
  attrs = FALSE
)
}
\arguments{
\item{file}{Path to the HDF5 file.}

\item{name}{Name of the dataset (e.g., "/data/matrix").}

\item{data}{The R object to write. Supported: \code{numeric}, \code{integer},
\code{logical}, \code{character}, \code{raw}.}

\item{dtype}{The target HDF5 data type. Defaults to \code{typeof(data)}.}

\item{dims}{An integer vector specifying dimensions, or \code{NULL} for a scalar.
Defaults to \code{dim(data)} if it exists, or \code{length(data)} otherwise.}

\item{compress}{A logical or an integer from 0-9. If \code{TRUE},
compression level 5 is used. If \code{FALSE} or \code{0}, no compression is used.
An integer \code{1-9} specifies the zlib compression level directly.}

\item{attrs}{Controls which R attributes of \code{data} are written to the HDF5 dataset.
Can be \code{FALSE} (the default, no attributes), \code{TRUE} (all attributes except \code{dim}),
a character vector of attribute names to include (e.g., \code{c("info", "version")}),
or a character vector of names to exclude, prefixed with \code{-} (e.g., \code{c("-class")}).
Mixing inclusive and exclusive names is not allowed.}
}
\value{
Invisibly returns \code{NULL}. This function is called for its side effects.
}
\description{
Writes an R object to an HDF5 file as a dataset. The file is created if
it does not exist. Handles dimension transposition automatically.
}
\details{
The \code{dtype} argument controls the on-disk storage type \strong{for numeric data only}.

If \code{dtype} is set to \code{"auto"} (the default), \code{h5lite} will automatically
select the most space-efficient type for numeric data that can safely
represent the full range of values. For example, writing \code{1:100} will
result in an 8-bit unsigned integer (\code{uint8}) dataset, which helps minimize
file size.

To override this for numeric data, you can specify an exact type. The input
is case-insensitive and allows for unambiguous partial matching. The full
list of supported values is:
\itemize{
\item \code{"auto"}, \code{"float"}, \code{"double"}
\item \code{"float16"}, \code{"float32"}, \code{"float64"}
\item \code{"int8"}, \code{"int16"}, \code{"int32"}, \code{"int64"}
\item \code{"uint8"}, \code{"uint16"}, \code{"uint32"}, \code{"uint64"}
\item \code{"char"}, \code{"short"}, \code{"int"}, \code{"long"}, \code{"llong"}
\item \code{"uchar"}, \code{"ushort"}, \code{"uint"}, \code{"ulong"}, \code{"ullong"}
}

Note: Types without a bit-width suffix (e.g., \code{"int"}, \code{"long"}) are system-
dependent and may have different sizes on different machines. For maximum file
portability, it is recommended to use types with explicit widths (e.g., \code{"int32"}).

For non-numeric data (\code{character}, \code{factor}, \code{raw}, \code{logical}), the storage
type is determined automatically and \strong{cannot be changed} by the \code{dtype}
argument. R \code{logical} vectors are stored as 8-bit unsigned integers (\code{uint8}),
as HDF5 does not have a native boolean datatype.
}
\examples{
file <- tempfile(fileext = ".h5")

# Write a simple vector (dtype is auto-detected as uint8)
h5_write(file, "vec1", 1:20)
h5_typeof(file, "vec1") # "uint8"

# Write a matrix, letting h5_write determine dimensions
mat <- matrix(rnorm(12), nrow = 4, ncol = 3)
h5_write(file, "group/mat", mat)
h5_dim(file, "group/mat") # c(4, 3)

# Overwrite the first vector, forcing a 32-bit integer type
h5_write(file, "vec1", 101:120, dtype = "int32")
h5_typeof(file, "vec1") # "int32"

# Write a scalar value
h5_write(file, "scalar", 3.14, dims = NULL)

unlink(file)
}
\seealso{
\code{\link[=h5_write_attr]{h5_write_attr()}}
}
