% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/write.r
\name{h5_write}
\alias{h5_write}
\title{Write an R Object to HDF5}
\usage{
h5_write(file, name, data, dtype = "auto", compress = TRUE, attrs = FALSE)
}
\arguments{
\item{file}{Path to the HDF5 file.}

\item{name}{Name of the dataset (e.g., "/data/matrix").}

\item{data}{The R object to write. Supported: \code{numeric}, \code{integer}, \code{complex},
\code{logical}, \code{character}, \code{factor}, \code{raw}, \code{matrix}, \code{data.frame}, \code{NULL}, and nested \code{list}s.}

\item{dtype}{The target HDF5 data type. See details.}

\item{compress}{A logical or an integer from 0-9. If \code{TRUE},
compression level 5 is used. If \code{FALSE} or \code{0}, no compression is used.
An integer \code{1-9} specifies the zlib compression level directly.}

\item{attrs}{Controls which R attributes of \code{data} are written to the HDF5 object.
Can be \code{FALSE} (the default), \code{TRUE} (all attributes except \code{dim}),
a character vector of attribute names to include (e.g., \code{c("info", "version")}),
or a character vector of names to exclude, prefixed with \code{-} (e.g., \code{c("-class")}).}
}
\value{
Invisibly returns \code{file}. This function is called for its side effects.
}
\description{
Writes an R object to an HDF5 file, creating the file if it does not exist.
This function can write atomic vectors, matrices, arrays, factors, \code{data.frame}s,
and nested \code{list}s.
}
\section{Writing Scalars}{

By default, \code{h5_write} saves single-element vectors as 1-dimensional arrays.
To write a true HDF5 scalar, wrap the value in \code{I()} to treat it "as-is."
For example, \code{h5_write(file, "x", I(5))} will create a scalar dataset, while
\code{h5_write(file, "x", 5)} will create a 1D array of length 1.
}

\section{Writing Lists}{

If \code{data} is a \code{list} (but not a \code{data.frame}), \code{h5_write} will write it
recursively, creating a corresponding group and dataset structure.
\itemize{
\item R \code{list} objects are created as HDF5 \strong{groups}.
\item All other supported R objects (vectors, matrices, arrays, factors, \code{data.frame}s)
are written as HDF5 \strong{datasets}.
\item Attributes of a list are written as HDF5 attributes on the corresponding group.
\item Before writing, a "dry run" is performed to validate that all objects and attributes
within the list are of a writeable type. If any part of the
structure is invalid, the function will throw an error and no data will be
written.
}
}

\section{Writing NULL}{

If \code{data} is \code{NULL}, \code{h5_write} will create an HDF5 \strong{null dataset}. This is
a dataset with a null dataspace, which contains no data.
}

\section{Writing Data Frames}{

\code{data.frame} objects are written as HDF5 \strong{compound datasets}. This is a
native HDF5 table-like structure that is highly efficient and portable.
}

\section{Writing Complex Numbers}{

\code{h5lite} writes R \code{complex} objects using the native HDF5 \code{H5T_COMPLEX}
datatype class, which was introduced in HDF5 version 2.0.0. As a result,
HDF5 files containing complex numbers written by \code{h5lite} can only be read
by other HDF5 tools that support HDF5 version 2.0.0 or later.
}

\section{Data Type Selection (\code{dtype})}{

The \code{dtype} argument controls the on-disk storage type \strong{for numeric data only}.

If \code{dtype} is set to \code{"auto"} (the default), \code{h5lite} will automatically
select the most space-efficient HDF5 type for numeric data that can safely
represent the full range of values. For example, writing \code{1:100} will
result in an 8-bit unsigned integer (\code{uint8}) dataset, which helps minimize
file size.

To override this behavior, you can specify an exact type. The input
is case-insensitive and allows for unambiguous partial matching. The full
list of supported values for numeric data is:
\itemize{
\item \code{"auto"}
\item \code{"float16"}, \code{"float32"}, \code{"float64"}
\item \code{"int8"}, \code{"int16"}, \code{"int32"}, \code{"int64"}
\item \code{"uint8"}, \code{"uint16"}, \code{"uint32"}, \code{"uint64"}
}

For non-numeric data (\code{character}, \code{complex}, \code{factor}, \code{raw}, and \code{logical}), the
storage type is determined automatically. For \code{logical} vectors, \code{h5lite}
follows the same rules as for integer vectors:
\itemize{
\item If the vector contains no \code{NA} values, it is saved using an efficient integer
type (e.g., \code{uint8}, where \code{FALSE} is 0 and \code{TRUE} is 1).
\item If the vector contains any \code{NA} values, it is automatically promoted to a
floating-point type (\code{float16}) to correctly preserve \code{NA}.
}
}

\section{Attribute Round-tripping}{

To properly round-trip an R object, it is helpful to set \code{attrs = TRUE}. This
preserves important R metadata—such as the \code{names} of a named vector, \code{row.names}
of a \code{data.frame}, or the \code{class} of an object—as HDF5 attributes.

\strong{Limitation}: HDF5 has no direct analog for R's \code{dimnames}.
Attempting to write an object that has \code{dimnames} (e.g., a named matrix)
with \code{attrs = TRUE} will result in an error. You must either remove the
\code{dimnames} or set \code{attrs = FALSE}.
}

\examples{
file <- tempfile(fileext = ".h5")

# Write a simple vector (dtype is auto-detected as uint8)
h5_write(file, "vec1", 1:20)
h5_typeof(file, "vec1") # "uint8"

# Write a matrix, letting h5_write determine dimensions
mat <- matrix(rnorm(12), nrow = 4, ncol = 3)
h5_write(file, "group/mat", mat)
h5_dim(file, "group/mat") # c(4, 3)

# Overwrite the first vector, forcing a 32-bit integer type
h5_write(file, "vec1", 101:120, dtype = "int32")
h5_typeof(file, "vec1") # "int32"

# Write a scalar value
h5_write(file, "scalar", I(3.14))

# Write a named vector and preserve its names by setting attrs = TRUE
named_vec <- c(a = 1, b = 2)
h5_write(file, "named_vector", named_vec, attrs = TRUE)

# Write a nested list, which creates groups and datasets
my_list <- list(
  config = list(version = 1.2, user = "test"),
  data = matrix(1:4, 2)
)
attr(my_list, "info") <- "Session data"
h5_write(file, "session_data", my_list)

h5_ls(file, recursive = TRUE)

unlink(file)
}
\seealso{
\code{\link[=h5_read]{h5_read()}}, \code{\link[=h5_write_attr]{h5_write_attr()}},
\code{vignette("atomic-vectors")},
\code{vignette("matrices")},
\code{vignette("data-frames")},
\code{vignette("data-organization")},
\code{vignette("attributes-in-depth")}
}
