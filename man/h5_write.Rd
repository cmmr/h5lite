% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/write.r
\name{h5_write}
\alias{h5_write}
\title{Write an R Object to HDF5}
\usage{
h5_write(data, file, name, attr = NULL, as = "auto", compress = TRUE)
}
\arguments{
\item{data}{The R object to write. Supported: \code{numeric}, \code{integer}, \code{complex},
\code{logical}, \code{character}, \code{factor}, \code{raw}, \code{matrix}, \code{data.frame}, \code{NULL},
and nested \code{list}s.}

\item{file}{The path to the HDF5 file.}

\item{name}{The name of the dataset or group to write (e.g., "/data/matrix").}

\item{attr}{The name of an attribute to write.
\itemize{
\item If \code{NULL} (default), \code{data} is written as a dataset or group at the path \code{name}.
\item If provided (string), \code{data} is written as an attribute named \code{attr} attached to the object \code{name}.
}}

\item{as}{The target HDF5 data type. Can be one of \code{"auto"}, \code{"float16"},
\code{"float32"}, \code{"float64"}, \code{"int8"}, \code{"int16"}, \code{"int32"}, \code{"int64"}, \code{"uint8"},
\code{"uint16"}, \code{"uint32"}, \code{"uint64"}, or \code{"skip"}. The default, \code{"auto"}, selects
the most space-efficient type for the data. See details below.}

\item{compress}{A logical or an integer from 0-9. If \code{TRUE},
compression level 5 is used. If \code{FALSE} or \code{0}, no compression is used.
An integer \code{1-9} specifies the zlib compression level directly.}
}
\value{
Invisibly returns \code{file}. This function is called for its side effects.
}
\description{
Writes an R object to an HDF5 file, creating the file if it does not exist.
This function acts as a unified writer for datasets, groups (lists), and attributes.
}
\section{Writing Scalars}{

By default, \code{h5_write} saves single-element vectors as 1-dimensional arrays.
To write a true HDF5 scalar, wrap the value in \code{I()} to treat it "as-is."
For example, \code{h5_write(I(5), file, "x")} will create a scalar dataset, while
\code{h5_write(5, file, "x")} will create a 1D array of length 1.
}

\section{Writing Lists}{

If \code{data} is a \code{list} (but not a \code{data.frame}), \code{h5_write} will write it
recursively, creating a corresponding group and dataset structure.
\itemize{
\item R \code{list} objects are created as HDF5 \strong{groups}.
\item All other supported R objects (vectors, matrices, arrays, factors, \code{data.frame}s)
are written as HDF5 \strong{datasets}.
\item Attributes of a list are written as HDF5 attributes on the corresponding group.
\item Before writing, a "dry run" is performed to validate that all objects and attributes
within the list are of a writeable type. If any part of the
structure is invalid, the function will throw an error and no data will be
written.
}
}

\section{Writing NULL}{

If \code{data} is \code{NULL}, \code{h5_write} will create an HDF5 \strong{null dataset}. This is
a dataset with a null dataspace, which contains no data.
}

\section{Writing Data Frames}{

\code{data.frame} objects are written as HDF5 \strong{compound datasets}. This is a
native HDF5 table-like structure that is highly efficient and portable.
}

\section{Writing Complex Numbers}{

\code{h5lite} writes R \code{complex} objects using the native HDF5 \code{H5T_COMPLEX}
datatype class, which was introduced in HDF5 version 2.0.0. As a result,
HDF5 files containing complex numbers written by \code{h5lite} can only be read
by other HDF5 tools that support HDF5 version 2.0.0 or later.
}

\section{Writing Date-Time Objects}{

\code{POSIXt} objects are automatically converted to character strings in
ISO 8601 format (\code{YYYY-MM-DDTHH:MM:SSZ}). This ensures that timestamps are
stored in a human-readable and unambiguous way. This conversion applies to
standalone \code{POSIXt} objects, as well as to columns within a \code{data.frame}.
}

\section{Data Type Selection (\code{as} Argument)}{

The \code{as} argument controls the on-disk storage type and only applies to
\code{integer}, \code{numeric}, and \code{logical} vectors. For all other data types
(\code{character}, \code{complex}, \code{factor}, \code{raw}), the storage type is determined
automatically.

The \code{as} argument can be one of the following:
\itemize{
\item \strong{Global:} A single string, e.g., \code{"auto"} (default), \code{"float32"}, \code{"int64"}.
\item \strong{Specific:} A named vector mapping names or type classes to HDF5 types.
Matches \code{h5_read} behavior:
\itemize{
\item \code{"col_name" = "type"}: Specific dataset/column.
\item \code{"@attr_name" = "type"}: Specific attached attribute.
\item \code{".int" = "type"}: Class-based (e.g., .int, .double, .logical).
\item \code{"." = "type"}: Global default fallback.
}
}

If \code{as} is set to \code{"auto"} (the default), \code{h5lite} will automatically
select the most space-efficient HDF5 type based on the following rules:
\enumerate{
\item If the data contains fractional values (e.g., \code{1.5}), it is stored as
\code{float64}.
\item If the data contains \code{NA}, \code{NaN}, or \code{Inf}, it is stored using the
smallest floating-point type (\code{float16}, \code{float32}, or \code{float64}) that
can precisely represent all integer values in the vector.
\item If the data contains only finite integers (this includes \code{logical}
vectors, where \code{FALSE} is 0 and \code{TRUE} is 1), \code{h5lite} selects the
smallest possible integer type (e.g., \code{uint8}, \code{int16}).
\item If integer values exceed R's safe integer range (\verb{+/- 2^53}), they are
automatically stored as \code{float64} to preserve precision.
}

To override this automatic behavior, you can specify an exact type. The full
list of supported values is:
\itemize{
\item \code{"auto"}, \code{"skip"}
\item \code{"float16"}, \code{"float32"}, \code{"float64"}
\item \code{"int8"}, \code{"int16"}, \code{"int32"}, \code{"int64"}
\item \code{"uint8"}, \code{"uint16"}, \code{"uint32"}, \code{"uint64"}
}
}

\examples{
file <- tempfile(fileext = ".h5")

# 1. Writing Basic Datasets
h5_write(1:10, file, "data/integers")
h5_write(rnorm(10), file, "data/floats")
h5_write(letters[1:5], file, "data/chars")

# 2. Writing Attributes
# Write an object first
h5_write(1:10, file, "data/vector")
# Attach an attribute to it using the 'attr' parameter
h5_write("My Description", file, "data/vector", attr = "description")
h5_write(100, file, "data/vector", attr = "scale_factor")

# 3. Writing Complex Structures (Lists/Groups)
my_list <- list(
  meta = list(id = 1, name = "Experiment A"),
  results = matrix(runif(9), 3, 3),
  valid = TRUE
)
h5_write(my_list, file, "experiment_1")

# 4. Writing Data Frames (Compound Datasets)
df <- data.frame(
  id = 1:5,
  score = c(10.5, 9.2, 8.4, 7.1, 6.0),
  grade = factor(c("A", "A", "B", "C", "D"))
)
h5_write(df, file, "records/scores")

# 5. Controlling Data Types (Compression)
# Store integers as 8-bit unsigned
h5_write(1:5, file, "compressed/small_ints", as = "uint8")

unlink(file)
}
\seealso{
\code{\link[=h5_read]{h5_read()}}
}
