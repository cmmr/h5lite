% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/write.r
\name{h5_write}
\alias{h5_write}
\title{Write an R Object to HDF5}
\usage{
h5_write(data, file, name, attr = NULL, as = "auto", compress = TRUE)
}
\arguments{
\item{data}{The R object to write. Supported: \code{numeric}, \code{integer}, \code{complex},
\code{logical}, \code{character}, \code{factor}, \code{raw}, \code{matrix}, \code{data.frame}, \code{NULL},
and nested \code{list}s.}

\item{file}{The path to the HDF5 file.}

\item{name}{The name of the dataset or group to write (e.g., "/data/matrix").}

\item{attr}{The name of an attribute to write.
\itemize{
\item If \code{NULL} (default), \code{data} is written as a dataset or group at the path \code{name}.
\item If provided (string), \code{data} is written as an attribute named \code{attr} attached to the object \code{name}.
}}

\item{as}{The target HDF5 data type. Can be one of \code{"auto"} (default),
\code{"skip"}, \code{"utf8"}, \code{"ascii"}, \code{"bfloat16"}, \code{"float16"}, \code{"float32"},
\code{"float64"}, \code{"int8"}, \code{"int16"}, \code{"int32"}, \code{"int64"}, \code{"uint8"},
\code{"uint16"}, \code{"uint32"}, or \code{"uint64"}. To use fixed length strings,
suffix \code{"utf8"} or \code{"ascii"} with \code{"[<int>]"} (e.g., \code{"ascii[100]"}). Omit
\code{"<int>"} (e.g. \code{"utf8[]"}) to use the longest string's length. \code{NA} can
only be stored in a floating point or variable width string data type.}

\item{compress}{A logical or an integer from 0-9. If \code{TRUE},
compression level 5 is used. If \code{FALSE} or \code{0}, no compression is used.
An integer \code{1-9} specifies the zlib compression level directly.}
}
\value{
Invisibly returns \code{file}. This function is called for its side effects.
}
\description{
Writes an R object to an HDF5 file, creating the file if it does not exist.
This function acts as a unified writer for datasets, groups (lists), and attributes.
}
\section{Writing Scalars}{

By default, \code{h5_write} saves single-element vectors as 1-dimensional arrays.
To write a true HDF5 scalar, wrap the value in \code{I()} to treat it "as-is."
For example, \code{h5_write(I(5), file, "x")} will create a scalar dataset, while
\code{h5_write(5, file, "x")} will create a 1D array of length 1.
}

\section{Writing Lists}{

If \code{data} is a \code{list} (but not a \code{data.frame}), \code{h5_write} will write it
recursively, creating a corresponding group and dataset structure.
\itemize{
\item R \code{list} objects are created as HDF5 \strong{groups}.
\item All other supported R objects (vectors, matrices, arrays, factors, \code{data.frame}s)
are written as HDF5 \strong{datasets}.
\item Attributes of a list are written as HDF5 attributes on the corresponding group.
\item Before writing, a "dry run" is performed to validate that all objects and attributes
within the list are of a writeable type. If any part of the
structure is invalid, the function will throw an error and no data will be
written.
}
}

\section{Writing NULL}{

If \code{data} is \code{NULL}, \code{h5_write} will create an HDF5 \strong{null dataset}. This is
a dataset with a null dataspace, which contains no data.
}

\section{Writing Data Frames}{

\code{data.frame} objects are written as HDF5 \strong{compound datasets}. This is a
native HDF5 table-like structure that is highly efficient and portable. If the
data.frame has row names, they will be written as an HDF5 dimension scale at
\strong{\if{html}{\out{<name>}}_rownames}.
}

\section{Writing Complex Numbers}{

\code{h5lite} writes R \code{complex} objects using the native HDF5 \code{H5T_COMPLEX}
datatype class, which was introduced in HDF5 version 2.0.0. As a result,
HDF5 files containing complex numbers written by \code{h5lite} can only be read
by other HDF5 tools that support HDF5 version 2.0.0 or later.
}

\section{Writing Date-Time Objects}{

\code{POSIXt} objects are automatically converted to character strings in
ISO 8601 format (\code{YYYY-MM-DDTHH:MM:SSZ}). This ensures that timestamps are
stored in a human-readable and unambiguous way. This conversion applies to
standalone \code{POSIXt} objects, as well as to columns within a \code{data.frame}.
}

\section{Dimension Scales}{

\code{h5lite} automatically writes \code{names}, \code{row.names}, and \code{dimnames} as
HDF5 dimension scales. Named vectors will generate an \verb{<name>_names}
dataset. A data.frame with row names will generate an \verb{<name>_rownames}
dataset (column names are saved internally in the original dataset).
Matrices will generate \verb{<name>_rownames} and \verb{<name>_colnames} datasets.
Arrays will generate \verb{<name>_dimscale_1}, \verb{<name>_dimscale_2}, etc.
Special HDF5 metadata attributes link the dimension scales to the dataset.
The dimension scales can be relocated with \code{h5_move()} without breaking the
link.
}

\section{Data Type Selection (\code{as} Argument)}{

The \code{as} argument controls the on-disk storage type.

The \code{as} argument can be one of the following:
\itemize{
\item \strong{Global:} A single string, e.g., \code{"auto"}, \code{"float32"}, \code{"ascii"}.
\item \strong{Specific:} A named vector mapping names or type classes to HDF5 types.
Matches \code{h5_read} behavior:
\itemize{
\item \code{"col_name" = "type"}: Specific dataset/column.
\item \code{"@attr_name" = "type"}: Specific attached attribute.
\item \code{".integer" = "type"}: Class-based (e.g., \code{.integer}, \code{.double}, \code{.logical}, \code{.character}, \code{.numeric}).
\item \code{"." = "type"}: Global default fallback (applies to all supported types).
}
}

\strong{Class-based Priority:}
When selecting a type based on class, specific selectors override general ones:
\enumerate{
\item \code{.integer} and \code{.double} (Highest Priority)
\item \code{.numeric} (Targets both integer and double)
\item \code{.} (Lowest Priority)
}

If \code{as} is set to \code{"auto"} (the default), \code{h5lite} will automatically
select \code{float64} for double vectors, \code{int32} for integer vectors, \code{uint8}
for logical vectors, and \code{utf8} for character vectors. If an integer or
logical vector contains \code{NA}, it is stored using \code{float64} to enable encoding
of \code{NA} as a sentinel value.

To override this automatic behavior, you can specify an exact type. The full
list of supported values is:
\itemize{
\item \code{"auto"}, \code{"skip"}
\item \code{"utf8"}, \code{"ascii"} (variable length strings)
\item \code{"utf8[<int>]"}, \code{"ascii[<int>]"} (fixed length strings - \verb{<int>} bytes wide)
\item \code{"utf8[]"}, \code{"ascii[]"} (fixed length strings - auto-selected byte width)
\item \code{"float16"}, \code{"float32"}, \code{"float64"}
\item \code{"int8"}, \code{"int16"}, \code{"int32"}, \code{"int64"}
\item \code{"uint8"}, \code{"uint16"}, \code{"uint32"}, \code{"uint64"}
}
}

\examples{
file <- tempfile(fileext = ".h5")

# 1. Writing Basic Datasets
h5_write(1:10, file, "data/integers")
h5_write(rnorm(10), file, "data/floats")
h5_write(letters[1:5], file, "data/chars")

# 2. Writing Attributes
# Write an object first
h5_write(1:10, file, "data/vector")
# Attach an attribute to it using the 'attr' parameter
h5_write("My Description", file, "data/vector", attr = "description")
h5_write(100, file, "data/vector", attr = "scale_factor")

# 3. Writing Complex Structures (Lists/Groups)
my_list <- list(
  meta = list(id = 1, name = "Experiment A"),
  results = matrix(runif(9), 3, 3),
  valid = TRUE
)
h5_write(my_list, file, "experiment_1")

# 4. Writing Data Frames (Compound Datasets)
df <- data.frame(
  id = 1:5,
  score = c(10.5, 9.2, 8.4, 7.1, 6.0),
  grade = factor(c("A", "A", "B", "C", "D"))
)
h5_write(df, file, "records/scores")

# 5. Controlling Data Types (Compression)
# Store integers as 8-bit unsigned
h5_write(1:5, file, "compressed/small_ints", as = "uint8")

unlink(file)
}
\seealso{
\code{\link[=h5_read]{h5_read()}}
}
